//! This file contains the entry point to the Unikernel Hypervisor. The uhyve utilizes KVM to
//! create a Virtual Machine and load the kernel.

use std::ptr;
use std::fs::{File,OpenOptions};
use std::os::unix::fs::OpenOptionsExt;
use std::os::unix::io::AsRawFd;
use libc;

use hermit::Isle;
use super::{Error, Result, NameIOCTL};
use super::vm::VirtualMachine;
use hermit::socket::Console;

use std::os::unix::net::UnixStream;

/// The normal way of defining a IOCTL interface is provided by C macros. In Rust we have our own
/// flawed macro system. The module below wraps a bunch of functions which are generated by the
/// ioctl! macro and need to be wrapped further to provide a safe interface.
pub mod ioctl {
    use hermit::uhyve::kvm_header::{KVMIO, kvm_msr_list, kvm_cpuid2_header, kvm_memory_region, kvm_dirty_log, kvm_memory_alias, kvm_userspace_memory_region, kvm_regs,kvm_sregs, kvm_enable_cap, kvm_mp_state};
    
    ioctl!(get_version with io!(KVMIO,  0x00));
    ioctl!(create_vm with io!(KVMIO, 0x01));
    ioctl!(read get_msr_index_list with KVMIO, 0x02; kvm_msr_list);
    ioctl!(get_vcpu_mmap_size with io!(KVMIO, 0x04));
    
    ioctl!(readwrite get_supported_cpuid with KVMIO, 0x05; kvm_cpuid2_header);
    ioctl!(read get_emulated_cpuid with KVMIO,0x09; kvm_cpuid2_header);
    ioctl!(write set_cpuid2 with KVMIO, 0x90; kvm_cpuid2_header);

    ioctl!(create_vcpu with io!(KVMIO, 0x41));
    ioctl!(read get_dirty_log with KVMIO, 0x42;  kvm_dirty_log);
    ioctl!(write set_memory_alias with KVMIO, 0x43; kvm_memory_alias);
    ioctl!(set_nr_mmu_pages with io!(KVMIO, 0x44));
    ioctl!(get_nr_mmu_pages with io!(KVMIO, 0x45));
    
    ioctl!(write set_memory_region with KVMIO, 0x40; kvm_memory_region);
    ioctl!(write set_user_memory_region with KVMIO, 0x46; kvm_userspace_memory_region);

    ioctl!(create_irqchip with io!(KVMIO, 0x60));

    ioctl!(run with io!(KVMIO, 0x80));
    ioctl!(read get_regs with KVMIO, 0x81; kvm_regs);
    ioctl!(write set_regs with KVMIO, 0x82; kvm_regs);
    ioctl!(read get_sregs with KVMIO, 0x83; kvm_sregs);
    ioctl!(write set_sregs with KVMIO, 0x84; kvm_sregs);

    ioctl!(check_extension with io!(KVMIO, 0x03));
    ioctl!(set_tss_addr with io!(KVMIO, 0x47));
    ioctl!(write set_identity_map_addr with KVMIO, 0x48; u64);
    ioctl!(write enable_cap with KVMIO, 0xa3; kvm_enable_cap);

    ioctl!(write set_mp_state with KVMIO, 0x99; kvm_mp_state);
}

/// KVM is freezed at version 12, so all others are invalid
#[derive(Debug)]
pub enum Version{
    Version12,
    Unsupported
}

/// This is the entry point of our module, it connects to the KVM device and wraps the functions
/// which accept the global file descriptor.
pub struct KVM {
    file: File
}

impl KVM {
    // Connects to the KVM hypervisor, by opening the virtual device /dev/kvm
    pub fn new() -> KVM {
        
        let kvm_file = OpenOptions::new()
            .read(true)
            .write(true)
            .custom_flags(libc::O_CLOEXEC)
            .open("/dev/kvm").unwrap();
  
        debug!("Connection to KVM is established.");
        
        KVM { file: kvm_file }
    }

    // Acquires the KVM version to seperate ancient systems
    pub fn version(&self) -> Result<Version> {
        unsafe {
            match ioctl::get_version(self.file.as_raw_fd(), ptr::null_mut()) {
                Ok(12) => Ok(Version::Version12),
                Ok(_)  => Ok(Version::Unsupported),
                Err(_) => Err(Error::IOCTL(NameIOCTL::GetVersion))
            }
        }
    }

    // Creates a new virtual machine and forwards the new fd to an object
    pub fn create_vm(&self, size: usize,num_cpus: u32) -> Result<VirtualMachine> {
        unsafe {
            match ioctl::create_vm(self.file.as_raw_fd(), ptr::null_mut()) {
                Ok(vm_fd) => VirtualMachine::new(self.file.as_raw_fd(), vm_fd, size,num_cpus),
                Err(_) => Err(Error::InternalError)
            }
        }


    }
}

pub struct Uhyve {
    kvm: KVM,
    vm: VirtualMachine,
    console: Console
}

impl Uhyve {
    pub fn new(path: &str, mem_size: u64, num_cpus: u32) -> Result<Uhyve> {
        let kvm = KVM::new();
        let mut vm = kvm.create_vm(mem_size as usize, num_cpus)?;
        let console = vm.console();
        vm.load_kernel(path)?;
        vm.init()?;
    
        Ok(Uhyve {
            kvm: kvm,
            vm: vm,
            console: console
        })
    }
}

impl Isle for Uhyve {
    fn num(&self) -> u8 {
        0
    }

    fn log_file(&self) -> Option<String> {
        None
    }

    fn log_path(&self) -> Option<String> {
        None
    }

    fn cpu_path(&self) -> Option<String> {
        None
    }

    fn run(&mut self) -> Result<()> {
        self.vm.run().map(|_| ())
    }

    fn output(&self) -> Result<String> {
        self.vm.output()
    }

    fn stop(&mut self) -> Result<i32> {
        self.vm.stop()
    }

    fn is_running(&mut self) -> Result<bool> {
        self.vm.is_running()
    }

    fn add_endpoint(&mut self, stream: UnixStream) -> Result<()> {
        self.console.lock().unwrap().push(stream);

        Ok(())
    }
}
